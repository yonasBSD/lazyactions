// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package github

import (
	"context"
	"sync"
)

// Ensure, that MockClient does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &MockClient{}

// MockClient is a mock implementation of Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked Client
//		mockedClient := &MockClient{
//			CancelRunFunc: func(ctx context.Context, repo Repository, runID int64) error {
//				panic("mock out the CancelRun method")
//			},
//			GetJobLogsFunc: func(ctx context.Context, repo Repository, jobID int64) (string, error) {
//				panic("mock out the GetJobLogs method")
//			},
//			ListJobsFunc: func(ctx context.Context, repo Repository, runID int64) ([]Job, error) {
//				panic("mock out the ListJobs method")
//			},
//			ListRunsFunc: func(ctx context.Context, repo Repository, opts *ListRunsOpts) ([]Run, error) {
//				panic("mock out the ListRuns method")
//			},
//			ListWorkflowsFunc: func(ctx context.Context, repo Repository) ([]Workflow, error) {
//				panic("mock out the ListWorkflows method")
//			},
//			RateLimitRemainingFunc: func() int {
//				panic("mock out the RateLimitRemaining method")
//			},
//			RerunFailedJobsFunc: func(ctx context.Context, repo Repository, runID int64) error {
//				panic("mock out the RerunFailedJobs method")
//			},
//			RerunWorkflowFunc: func(ctx context.Context, repo Repository, runID int64) error {
//				panic("mock out the RerunWorkflow method")
//			},
//			TriggerWorkflowFunc: func(ctx context.Context, repo Repository, workflowFile string, ref string, inputs map[string]interface{}) error {
//				panic("mock out the TriggerWorkflow method")
//			},
//		}
//
//		// use mockedClient in code that requires Client
//		// and then make assertions.
//
//	}
type MockClient struct {
	// CancelRunFunc mocks the CancelRun method.
	CancelRunFunc func(ctx context.Context, repo Repository, runID int64) error

	// GetJobLogsFunc mocks the GetJobLogs method.
	GetJobLogsFunc func(ctx context.Context, repo Repository, jobID int64) (string, error)

	// ListJobsFunc mocks the ListJobs method.
	ListJobsFunc func(ctx context.Context, repo Repository, runID int64) ([]Job, error)

	// ListRunsFunc mocks the ListRuns method.
	ListRunsFunc func(ctx context.Context, repo Repository, opts *ListRunsOpts) ([]Run, error)

	// ListWorkflowsFunc mocks the ListWorkflows method.
	ListWorkflowsFunc func(ctx context.Context, repo Repository) ([]Workflow, error)

	// RateLimitRemainingFunc mocks the RateLimitRemaining method.
	RateLimitRemainingFunc func() int

	// RerunFailedJobsFunc mocks the RerunFailedJobs method.
	RerunFailedJobsFunc func(ctx context.Context, repo Repository, runID int64) error

	// RerunWorkflowFunc mocks the RerunWorkflow method.
	RerunWorkflowFunc func(ctx context.Context, repo Repository, runID int64) error

	// TriggerWorkflowFunc mocks the TriggerWorkflow method.
	TriggerWorkflowFunc func(ctx context.Context, repo Repository, workflowFile string, ref string, inputs map[string]interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// CancelRun holds details about calls to the CancelRun method.
		CancelRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
			// RunID is the runID argument value.
			RunID int64
		}
		// GetJobLogs holds details about calls to the GetJobLogs method.
		GetJobLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
			// JobID is the jobID argument value.
			JobID int64
		}
		// ListJobs holds details about calls to the ListJobs method.
		ListJobs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
			// RunID is the runID argument value.
			RunID int64
		}
		// ListRuns holds details about calls to the ListRuns method.
		ListRuns []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
			// Opts is the opts argument value.
			Opts *ListRunsOpts
		}
		// ListWorkflows holds details about calls to the ListWorkflows method.
		ListWorkflows []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
		}
		// RateLimitRemaining holds details about calls to the RateLimitRemaining method.
		RateLimitRemaining []struct {
		}
		// RerunFailedJobs holds details about calls to the RerunFailedJobs method.
		RerunFailedJobs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
			// RunID is the runID argument value.
			RunID int64
		}
		// RerunWorkflow holds details about calls to the RerunWorkflow method.
		RerunWorkflow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
			// RunID is the runID argument value.
			RunID int64
		}
		// TriggerWorkflow holds details about calls to the TriggerWorkflow method.
		TriggerWorkflow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo Repository
			// WorkflowFile is the workflowFile argument value.
			WorkflowFile string
			// Ref is the ref argument value.
			Ref string
			// Inputs is the inputs argument value.
			Inputs map[string]interface{}
		}
	}
	lockCancelRun          sync.RWMutex
	lockGetJobLogs         sync.RWMutex
	lockListJobs           sync.RWMutex
	lockListRuns           sync.RWMutex
	lockListWorkflows      sync.RWMutex
	lockRateLimitRemaining sync.RWMutex
	lockRerunFailedJobs    sync.RWMutex
	lockRerunWorkflow      sync.RWMutex
	lockTriggerWorkflow    sync.RWMutex
}

// CancelRun calls CancelRunFunc.
func (mock *MockClient) CancelRun(ctx context.Context, repo Repository, runID int64) error {
	if mock.CancelRunFunc == nil {
		panic("MockClient.CancelRunFunc: method is nil but Client.CancelRun was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}{
		Ctx:   ctx,
		Repo:  repo,
		RunID: runID,
	}
	mock.lockCancelRun.Lock()
	mock.calls.CancelRun = append(mock.calls.CancelRun, callInfo)
	mock.lockCancelRun.Unlock()
	return mock.CancelRunFunc(ctx, repo, runID)
}

// CancelRunCalls gets all the calls that were made to CancelRun.
// Check the length with:
//
//	len(mockedClient.CancelRunCalls())
func (mock *MockClient) CancelRunCalls() []struct {
	Ctx   context.Context
	Repo  Repository
	RunID int64
} {
	var calls []struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}
	mock.lockCancelRun.RLock()
	calls = mock.calls.CancelRun
	mock.lockCancelRun.RUnlock()
	return calls
}

// GetJobLogs calls GetJobLogsFunc.
func (mock *MockClient) GetJobLogs(ctx context.Context, repo Repository, jobID int64) (string, error) {
	if mock.GetJobLogsFunc == nil {
		panic("MockClient.GetJobLogsFunc: method is nil but Client.GetJobLogs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Repo  Repository
		JobID int64
	}{
		Ctx:   ctx,
		Repo:  repo,
		JobID: jobID,
	}
	mock.lockGetJobLogs.Lock()
	mock.calls.GetJobLogs = append(mock.calls.GetJobLogs, callInfo)
	mock.lockGetJobLogs.Unlock()
	return mock.GetJobLogsFunc(ctx, repo, jobID)
}

// GetJobLogsCalls gets all the calls that were made to GetJobLogs.
// Check the length with:
//
//	len(mockedClient.GetJobLogsCalls())
func (mock *MockClient) GetJobLogsCalls() []struct {
	Ctx   context.Context
	Repo  Repository
	JobID int64
} {
	var calls []struct {
		Ctx   context.Context
		Repo  Repository
		JobID int64
	}
	mock.lockGetJobLogs.RLock()
	calls = mock.calls.GetJobLogs
	mock.lockGetJobLogs.RUnlock()
	return calls
}

// ListJobs calls ListJobsFunc.
func (mock *MockClient) ListJobs(ctx context.Context, repo Repository, runID int64) ([]Job, error) {
	if mock.ListJobsFunc == nil {
		panic("MockClient.ListJobsFunc: method is nil but Client.ListJobs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}{
		Ctx:   ctx,
		Repo:  repo,
		RunID: runID,
	}
	mock.lockListJobs.Lock()
	mock.calls.ListJobs = append(mock.calls.ListJobs, callInfo)
	mock.lockListJobs.Unlock()
	return mock.ListJobsFunc(ctx, repo, runID)
}

// ListJobsCalls gets all the calls that were made to ListJobs.
// Check the length with:
//
//	len(mockedClient.ListJobsCalls())
func (mock *MockClient) ListJobsCalls() []struct {
	Ctx   context.Context
	Repo  Repository
	RunID int64
} {
	var calls []struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}
	mock.lockListJobs.RLock()
	calls = mock.calls.ListJobs
	mock.lockListJobs.RUnlock()
	return calls
}

// ListRuns calls ListRunsFunc.
func (mock *MockClient) ListRuns(ctx context.Context, repo Repository, opts *ListRunsOpts) ([]Run, error) {
	if mock.ListRunsFunc == nil {
		panic("MockClient.ListRunsFunc: method is nil but Client.ListRuns was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Repo Repository
		Opts *ListRunsOpts
	}{
		Ctx:  ctx,
		Repo: repo,
		Opts: opts,
	}
	mock.lockListRuns.Lock()
	mock.calls.ListRuns = append(mock.calls.ListRuns, callInfo)
	mock.lockListRuns.Unlock()
	return mock.ListRunsFunc(ctx, repo, opts)
}

// ListRunsCalls gets all the calls that were made to ListRuns.
// Check the length with:
//
//	len(mockedClient.ListRunsCalls())
func (mock *MockClient) ListRunsCalls() []struct {
	Ctx  context.Context
	Repo Repository
	Opts *ListRunsOpts
} {
	var calls []struct {
		Ctx  context.Context
		Repo Repository
		Opts *ListRunsOpts
	}
	mock.lockListRuns.RLock()
	calls = mock.calls.ListRuns
	mock.lockListRuns.RUnlock()
	return calls
}

// ListWorkflows calls ListWorkflowsFunc.
func (mock *MockClient) ListWorkflows(ctx context.Context, repo Repository) ([]Workflow, error) {
	if mock.ListWorkflowsFunc == nil {
		panic("MockClient.ListWorkflowsFunc: method is nil but Client.ListWorkflows was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Repo Repository
	}{
		Ctx:  ctx,
		Repo: repo,
	}
	mock.lockListWorkflows.Lock()
	mock.calls.ListWorkflows = append(mock.calls.ListWorkflows, callInfo)
	mock.lockListWorkflows.Unlock()
	return mock.ListWorkflowsFunc(ctx, repo)
}

// ListWorkflowsCalls gets all the calls that were made to ListWorkflows.
// Check the length with:
//
//	len(mockedClient.ListWorkflowsCalls())
func (mock *MockClient) ListWorkflowsCalls() []struct {
	Ctx  context.Context
	Repo Repository
} {
	var calls []struct {
		Ctx  context.Context
		Repo Repository
	}
	mock.lockListWorkflows.RLock()
	calls = mock.calls.ListWorkflows
	mock.lockListWorkflows.RUnlock()
	return calls
}

// RateLimitRemaining calls RateLimitRemainingFunc.
func (mock *MockClient) RateLimitRemaining() int {
	if mock.RateLimitRemainingFunc == nil {
		panic("MockClient.RateLimitRemainingFunc: method is nil but Client.RateLimitRemaining was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRateLimitRemaining.Lock()
	mock.calls.RateLimitRemaining = append(mock.calls.RateLimitRemaining, callInfo)
	mock.lockRateLimitRemaining.Unlock()
	return mock.RateLimitRemainingFunc()
}

// RateLimitRemainingCalls gets all the calls that were made to RateLimitRemaining.
// Check the length with:
//
//	len(mockedClient.RateLimitRemainingCalls())
func (mock *MockClient) RateLimitRemainingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRateLimitRemaining.RLock()
	calls = mock.calls.RateLimitRemaining
	mock.lockRateLimitRemaining.RUnlock()
	return calls
}

// RerunFailedJobs calls RerunFailedJobsFunc.
func (mock *MockClient) RerunFailedJobs(ctx context.Context, repo Repository, runID int64) error {
	if mock.RerunFailedJobsFunc == nil {
		panic("MockClient.RerunFailedJobsFunc: method is nil but Client.RerunFailedJobs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}{
		Ctx:   ctx,
		Repo:  repo,
		RunID: runID,
	}
	mock.lockRerunFailedJobs.Lock()
	mock.calls.RerunFailedJobs = append(mock.calls.RerunFailedJobs, callInfo)
	mock.lockRerunFailedJobs.Unlock()
	return mock.RerunFailedJobsFunc(ctx, repo, runID)
}

// RerunFailedJobsCalls gets all the calls that were made to RerunFailedJobs.
// Check the length with:
//
//	len(mockedClient.RerunFailedJobsCalls())
func (mock *MockClient) RerunFailedJobsCalls() []struct {
	Ctx   context.Context
	Repo  Repository
	RunID int64
} {
	var calls []struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}
	mock.lockRerunFailedJobs.RLock()
	calls = mock.calls.RerunFailedJobs
	mock.lockRerunFailedJobs.RUnlock()
	return calls
}

// RerunWorkflow calls RerunWorkflowFunc.
func (mock *MockClient) RerunWorkflow(ctx context.Context, repo Repository, runID int64) error {
	if mock.RerunWorkflowFunc == nil {
		panic("MockClient.RerunWorkflowFunc: method is nil but Client.RerunWorkflow was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}{
		Ctx:   ctx,
		Repo:  repo,
		RunID: runID,
	}
	mock.lockRerunWorkflow.Lock()
	mock.calls.RerunWorkflow = append(mock.calls.RerunWorkflow, callInfo)
	mock.lockRerunWorkflow.Unlock()
	return mock.RerunWorkflowFunc(ctx, repo, runID)
}

// RerunWorkflowCalls gets all the calls that were made to RerunWorkflow.
// Check the length with:
//
//	len(mockedClient.RerunWorkflowCalls())
func (mock *MockClient) RerunWorkflowCalls() []struct {
	Ctx   context.Context
	Repo  Repository
	RunID int64
} {
	var calls []struct {
		Ctx   context.Context
		Repo  Repository
		RunID int64
	}
	mock.lockRerunWorkflow.RLock()
	calls = mock.calls.RerunWorkflow
	mock.lockRerunWorkflow.RUnlock()
	return calls
}

// TriggerWorkflow calls TriggerWorkflowFunc.
func (mock *MockClient) TriggerWorkflow(ctx context.Context, repo Repository, workflowFile string, ref string, inputs map[string]interface{}) error {
	if mock.TriggerWorkflowFunc == nil {
		panic("MockClient.TriggerWorkflowFunc: method is nil but Client.TriggerWorkflow was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Repo         Repository
		WorkflowFile string
		Ref          string
		Inputs       map[string]interface{}
	}{
		Ctx:          ctx,
		Repo:         repo,
		WorkflowFile: workflowFile,
		Ref:          ref,
		Inputs:       inputs,
	}
	mock.lockTriggerWorkflow.Lock()
	mock.calls.TriggerWorkflow = append(mock.calls.TriggerWorkflow, callInfo)
	mock.lockTriggerWorkflow.Unlock()
	return mock.TriggerWorkflowFunc(ctx, repo, workflowFile, ref, inputs)
}

// TriggerWorkflowCalls gets all the calls that were made to TriggerWorkflow.
// Check the length with:
//
//	len(mockedClient.TriggerWorkflowCalls())
func (mock *MockClient) TriggerWorkflowCalls() []struct {
	Ctx          context.Context
	Repo         Repository
	WorkflowFile string
	Ref          string
	Inputs       map[string]interface{}
} {
	var calls []struct {
		Ctx          context.Context
		Repo         Repository
		WorkflowFile string
		Ref          string
		Inputs       map[string]interface{}
	}
	mock.lockTriggerWorkflow.RLock()
	calls = mock.calls.TriggerWorkflow
	mock.lockTriggerWorkflow.RUnlock()
	return calls
}
